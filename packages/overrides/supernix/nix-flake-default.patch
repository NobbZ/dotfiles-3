diff --git a/src/libcmd/installables.cc b/src/libcmd/installables.cc
index 59162c4..e635018 100644
--- a/src/libcmd/installables.cc
+++ b/src/libcmd/installables.cc
@@ -23,6 +23,23 @@
 
 namespace nix {
 
+std::string InstallablesSettings::getDefaultFlake(std::string_view url)
+{
+    std::string res = defaultFlake;
+    if (res == "") {
+        throw UsageError("don't know how to handle installable '%s' without flake URL, because the option 'default-flake' is not set", url);
+    }
+    return res;
+}
+
+InstallablesSettings installablesSettings;
+
+static GlobalConfig::Register rInstallablesSettings(&installablesSettings);
+
+const static std::regex attrPathRegex(
+    R"((?:[a-zA-Z0-9_"-][a-zA-Z0-9_".-]*(?:\^((\*)|([a-z]+(,[a-z]+)*)))?))",
+    std::regex::ECMAScript);
+
 MixFlakeOptions::MixFlakeOptions()
 {
     auto category = "Common flake-related options";
@@ -269,15 +286,23 @@ void completeFlakeRefWithFragment(
     /* Look for flake output attributes that match the
        prefix. */
     try {
+        bool isAttrPath = std::regex_match(prefix.begin(), prefix.end(), attrPathRegex);
         auto hash = prefix.find('#');
-        if (hash == std::string::npos) {
-            completeFlakeRef(evalState->store, prefix);
-        } else {
-            completionType = ctAttrs;
-
-            auto fragment = prefix.substr(hash + 1);
-            auto flakeRefS = std::string(prefix.substr(0, hash));
-            auto flakeRef = parseFlakeRef(expandTilde(flakeRefS), absPath("."));
+        if (isAttrPath || hash != std::string::npos) {
+            auto fragment =
+                isAttrPath
+                ? prefix
+                : prefix.substr(hash + 1);
+
+            auto flakeRefS =
+                isAttrPath
+                ? std::string(installablesSettings.getDefaultFlake(prefix))
+                : std::string(prefix.substr(0, hash));
+
+            // FIXME: do tilde expansion.
+            auto flakeRef = parseFlakeRef(
+                flakeRefS,
+                isAttrPath ? std::optional<std::string>{} : absPath("."));
 
             auto evalCache = openEvalCache(*evalState,
                 std::make_shared<flake::LockedFlake>(lockFlake(*evalState, flakeRef, lockFlags)));
@@ -308,7 +333,13 @@ void completeFlakeRefWithFragment(
                         auto attrPath2 = (*attr)->getAttrPath(attr2);
                         /* Strip the attrpath prefix. */
                         attrPath2.erase(attrPath2.begin(), attrPath2.begin() + attrPathPrefix.size());
-                        completions->add(flakeRefS + "#" + concatStringsSep(".", evalState->symbols.resolve(attrPath2)));
+
+                        std::string resolvedAttrPath2 = concatStringsSep(".", evalState->symbols.resolve(attrPath2));
+
+                        if (isAttrPath)
+                            completions->add(resolvedAttrPath2);
+                        else
+                            completions->add(flakeRefS + "#" + resolvedAttrPath2);
                     }
                 }
             }
@@ -326,6 +357,8 @@ void completeFlakeRefWithFragment(
     } catch (Error & e) {
         warn(e.msg());
     }
+
+    completeFlakeRef(evalState->store, prefix);
 }
 
 void completeFlakeRef(ref<Store> store, std::string_view prefix)
@@ -345,7 +378,7 @@ void completeFlakeRef(ref<Store> store, std::string_view prefix)
             if (!hasPrefix(prefix, "flake:") && hasPrefix(from, "flake:")) {
                 std::string from2(from, 6);
                 if (hasPrefix(from2, prefix))
-                    completions->add(from2);
+                    completions->add(from2 + "#");
             } else {
                 if (hasPrefix(from, prefix))
                     completions->add(from);
@@ -753,6 +786,16 @@ FlakeRef InstallableFlake::nixpkgsFlakeRef() const
     return Installable::nixpkgsFlakeRef();
 }
 
+static std::tuple<FlakeRef, std::string, OutputsSpec> parseOnlyAttrPath(
+    const std::string &s) {
+    auto [fragment, outputsSpec] = parseOutputsSpec(s);
+    return {
+        parseFlakeRef(installablesSettings.getDefaultFlake(s), {}),
+        fragment,
+        outputsSpec
+    };
+}
+
 std::vector<std::shared_ptr<Installable>> SourceExprCommand::parseInstallables(
     ref<Store> store, std::vector<std::string> ss)
 {
@@ -808,7 +851,13 @@ std::vector<std::shared_ptr<Installable>> SourceExprCommand::parseInstallables(
             }
 
             try {
-                auto [flakeRef, fragment, outputsSpec] = parseFlakeRefWithFragmentAndOutputsSpec(s, absPath("."));
+                bool isAttrPath = std::regex_match(s, attrPathRegex);
+
+                auto [flakeRef, fragment, outputsSpec] =
+                    isAttrPath
+                    ? parseOnlyAttrPath(s)
+                    : parseFlakeRefWithFragmentAndOutputsSpec(s, absPath("."));
+
                 result.push_back(std::make_shared<InstallableFlake>(
                         this,
                         getEvalState(),
diff --git a/src/libcmd/installables.hh b/src/libcmd/installables.hh
index 948f789..89d6221 100644
--- a/src/libcmd/installables.hh
+++ b/src/libcmd/installables.hh
@@ -12,6 +12,16 @@
 
 namespace nix {
 
+struct InstallablesSettings : Config
+{
+    Setting<std::string> defaultFlake{this, "", "default-flake",
+        "The default flake URL when using the command line interface"};
+
+    std::string getDefaultFlake(std::string_view url);
+};
+
+extern InstallablesSettings installablesSettings;
+
 struct DrvInfo;
 struct SourceExprCommand;
 
